{
  "title": "Design Patterns: Singleton and Factory",
  "description": "Learn the purpose behind common patterns.",
  "content": [
    {
      "type": "text",
      "text": "You’ve mastered recursion and complex problem solving. Now it’s time to learn design patterns, which are reusable solutions to common programming problems. We’ll focus on two fundamental patterns: Singleton and Factory. Understanding these patterns improves code structure, maintainability, and scalability."
    },
    {
      "type": "text",
      "text": "The Singleton pattern ensures a class has only one instance and provides a global point of access to it. This is useful for managing resources that should only exist once, such as a configuration manager or logging system."
    },
    {
      "type": "code-quiz",
      "language": "csharp",
      "prompt": "Implement a Singleton class Logger with a method Log(string message) that prints the message. Ensure only one instance of Logger can exist. In Main, get the instance and call Log('Hello Singleton').",
      "prefixCode": "using System;\nclass Program {\n static void Main() {\n",
      "starterCode": " // Get Singleton instance and call Log\n",
      "suffixCode": " }\n // Define Logger Singleton class here\n}",
      "desiredOutput": {
        "type": "exact",
        "value": "Hello Singleton"
      }
    },
    {
      "type": "text",
      "text": "The Factory pattern provides an interface for creating objects but allows subclasses to decide which class to instantiate. This helps decouple object creation from usage, making your code more flexible and easier to extend."
    },
    {
      "type": "code-quiz",
      "language": "csharp",
      "prompt": "Create an abstract class Enemy and two subclasses, Goblin and Troll. Implement a Factory class EnemyFactory with a method CreateEnemy(string type) that returns a Goblin or Troll based on type. In Main, create a Goblin using the factory and print 'Goblin created'.",
      "prefixCode": "using System;\nclass Program {\n static void Main() {\n",
      "starterCode": " // Use EnemyFactory to create a Goblin\n",
      "suffixCode": " }\n // Define Enemy, Goblin, Troll, and EnemyFactory classes here\n}",
      "desiredOutput": {
        "type": "exact",
        "value": "Goblin created"
      }
    },
    {
      "type": "text",
      "text": "Design patterns like Singleton and Factory solve recurring design problems and make your code more organized. Singleton ensures controlled access to a single instance, while Factory separates object creation from its use, enabling flexible and maintainable code."
    },
    {
      "type": "multiple-choice-quiz",
      "question": "Which statement about design patterns is correct?",
      "options": [
        {
          "id": "a",
          "text": "Singleton allows multiple instances of a class"
        },
        {
          "id": "b",
          "text": "Factory decouples object creation from usage",
          "correct": true
        },
        {
          "id": "c",
          "text": "Singleton and Factory are only used in C#"
        },
        {
          "id": "d",
          "text": "Design patterns always make code slower"
        }
      ],
      "explanation": "Design patterns provide reusable solutions. The Factory pattern decouples object creation from usage, making code flexible. Singleton restricts a class to a single instance."
    },
    {
      "type": "text",
      "text": "Final challenge: Implement a Logger Singleton and an EnemyFactory in a single program. Use the Logger to print messages when creating different enemy types using the factory."
    },
    {
      "type": "text",
      "text": "Reflection: You now understand Singleton and Factory patterns, which help organize code and solve common design problems. Recognizing where to apply these patterns improves software quality. The next lesson will cover creating simple turn-based game logic using these and previous concepts."
    }
  ]
}
