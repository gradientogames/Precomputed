{
  "title": "Understanding Pointers in C",
  "description": "Learn how pointers let you control memory directly and write more powerful programs.",
  "content": [
    {
      "type": "code-quiz",
      "language": "c",
      "prompt": "",
      "starterCode": "// Your code here",
      "prefixCode": "#include <stdio.h>\n\nint main() {\n",
      "suffixCode": "    return 0;\n}",
      "desiredOutput": { "type": "none" },
      "maxLines": -1,
      "maxStringLength": -1
    },
    {
      "type": "text",
      "text": "In C, a pointer is a variable that stores the memory address of another variable. You can think of it as a signpost. Instead of holding a value, it points to where the value lives in memory."
    },
    {
      "type": "text",
      "text": "Why should you care? Because pointers give you power. You can pass large data efficiently, work with arrays directly, and even control hardware. Without pointers, most of C’s low-level magic wouldn’t exist."
    },
    {
      "type": "text",
      "text": "Let’s start simple. You’ll first create a pointer that points to an integer, then use it to change that integer’s value. You’ll see how the * operator lets you access the value stored at a pointer’s address."
    },
    {
      "type": "code-quiz",
      "language": "c",
      "prompt": "Create an integer variable called number and a pointer that points to it. Then, use the pointer to change number’s value to 10.",
      "starterCode": "#include <stdio.h>\n\nint main() {\n    int number = 5;\n    int *ptr; // create a pointer\n\n    // Your code here\n\n    printf(\"%d\", number);\n    return 0;\n}",
      "prefixCode": "",
      "suffixCode": "",
      "desiredOutput": { "type": "exact", "value": "10" },
      "maxLines": 50,
      "maxStringLength": -1
    },
    {
      "type": "text",
      "text": "Here’s what’s happening: *ptr = 10; means you’re not changing the pointer itself, but the value stored at the memory address it points to. That’s dereferencing. Once you understand this, you can control data anywhere in memory."
    },
    {
      "type": "multiple-choice-quiz",
      "question": "What does the * operator do when used with a pointer?",
      "options": [
        { "id": "a", "text": "Declares a pointer variable." },
        { "id": "b", "text": "Gets the value stored at the memory address.", "correct": true },
        { "id": "c", "text": "Gets the address of a variable." },
        { "id": "d", "text": "Multiplies the pointer by a number." }
      ],
      "explanation": "The * operator dereferences the pointer, letting you access or modify the value stored in the memory location."
    },
    {
      "type": "text",
      "text": "Pointers and addresses go hand in hand. The & operator gets the address of a variable. When you write ptr = &number;, you’re saying: ‘point to the memory location of number.’"
    },
    {
      "type": "code-quiz",
      "language": "c",
      "prompt": "Print the memory address of a variable using the & operator. Try printing both the address and the value of the variable.",
      "starterCode": "#include <stdio.h>\n\nint main() {\n    int age = 20;\n\n    // Your code here\n\n    return 0;\n}",
      "prefixCode": "",
      "suffixCode": "",
      "desiredOutput": { "type": "pointer" },
      "maxLines": 50,
      "maxStringLength": -1
    },
    {
      "type": "text",
      "text": "Now, let’s push this idea further. When you pass variables into functions, you’re usually passing copies. But with pointers, you can pass the actual memory address. That means a function can modify the original variable directly."
    },
    {
      "type": "code-quiz",
      "language": "c",
      "prompt": "Write a function that doubles an integer using a pointer.",
      "starterCode": "#include <stdio.h>\n\nvoid doubleValue(int *ptr) {\n    // Your code here\n}\n\nint main() {\n    int number = 5;\n    doubleValue(&number);\n    printf(\"%d\", number);\n    return 0;\n}",
      "prefixCode": "",
      "suffixCode": "",
      "desiredOutput": { "type": "exact", "value": "10" },
      "maxLines": 80,
      "maxStringLength": -1
    },
    {
      "type": "multiple-choice-quiz",
      "question": "Why do we pass &number instead of number to the function?",
      "options": [
        { "id": "a", "text": "Because we want to pass a copy of the value." },
        { "id": "b", "text": "Because we want the function to modify the original variable.", "correct": true },
        { "id": "c", "text": "Because &number doubles the value automatically." },
        { "id": "d", "text": "Because pointers can’t be used inside functions." }
      ],
      "explanation": "Using &number passes the address of the variable, allowing the function to access and modify it directly."
    },
    {
      "type": "text",
      "text": "Time for your final challenge. You’ll combine everything you’ve learned about addresses, dereferencing, and passing pointers into functions."
    },
    {
      "type": "code-quiz",
      "language": "c",
      "prompt": "Write a function called swap that swaps the values of two integers using pointers. Then call it from main and print the result.",
      "starterCode": "#include <stdio.h>\n\nvoid swap(int *a, int *b) {\n    // Your code here\n}\n\nint main() {\n    int x = 3;\n    int y = 7;\n\n    swap(&x, &y);\n    printf(\"%d %d\", x, y);\n    return 0;\n}",
      "prefixCode": "",
      "suffixCode": "",
      "desiredOutput": { "type": "exact", "value": "7 3" },
      "maxLines": 100,
      "maxStringLength": -1
    },
    {
      "type": "text",
      "text": "You did it. You’ve used pointers to manipulate memory, pass variables by reference, and even swap values. The idea might seem abstract at first, but pointers are what make C such a powerful and flexible language."
    },
    {
      "type": "text",
      "text": "Take a moment to reflect. Pointers aren’t just syntax. They’re a way of thinking. You’re not just working with data, you’re managing where it lives, how it moves, and who can access it. That’s real control."
    }
  ]
}
