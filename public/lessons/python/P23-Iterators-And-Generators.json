{
  "title": "Iterators and Generators",
  "description": "Learn how for really works under the hood.",
  "content": [
    {
      "type": "text",
      "text": "In Python, an iterator is an object that produces the next value each time you call next() on it. Iterators allow you to loop over data structures like lists, tuples, and sets without manually managing indexes."
    },
    {
      "type": "text",
      "text": "Any object that implements the __iter__() and __next__() methods is an iterator. The __iter__() method returns the iterator object itself, and __next__() returns the next value or raises StopIteration when finished."
    },
    {
      "type": "code-quiz",
      "language": "python",
      "prompt": "Create an iterator over the list [1, 2, 3] and use next() to print the first two elements.",
      "starterCode": "nums = [1, 2, 3]\nit = iter(nums)\nprint(next(it))\nprint(next(it))",
      "desiredOutput": { "type": "exact", "value": "1\n2" }
    },
    {
      "type": "text",
      "text": "Generators are a convenient way to create iterators using functions and the yield keyword. When a function contains yield, calling it returns a generator object that produces values one at a time, only as needed."
    },
    {
      "type": "code-quiz",
      "language": "python",
      "prompt": "Define a generator function gen_numbers() that yields 1, 2, 3. Use a for loop to print all values.",
      "starterCode": "def gen_numbers():\n    yield 1\n    yield 2\n    yield 3\n\nfor n in gen_numbers():\n    print(n)",
      "desiredOutput": { "type": "exact", "value": "1\n2\n3" }
    },
    {
      "type": "text",
      "text": "Generators are memory-efficient because they produce values on the fly instead of storing everything in memory. This is especially useful for large sequences or infinite streams."
    },
    {
      "type": "code-quiz",
      "language": "python",
      "prompt": "Write a generator function squares(n) that yields squares of numbers from 1 to n. Print the squares up to 5.",
      "starterCode": "def squares(n):\n    for i in range(1, n+1):\n        yield i*i\n\nfor s in squares(5):\n    print(s)",
      "desiredOutput": { "type": "exact", "value": "1\n4\n9\n16\n25" }
    },
    {
      "type": "text",
      "text": "You can also iterate over any iterable with a for loop, which internally calls iter() and next(). This shows that Python’s for loop is built on the iterator protocol."
    },
    {
      "type": "multiple-choice-quiz",
      "question": "What does the yield keyword do in Python?",
      "options": [
        { "id": "a", "text": "Stops the function permanently" },
        { "id": "b", "text": "Returns a value and pauses the function, making it a generator", "correct": true },
        { "id": "c", "text": "Raises an exception" },
        { "id": "d", "text": "Converts a function into a list" }
      ],
      "explanation": "yield produces a value and suspends the function’s state, allowing it to resume later. This is how generator functions create iterators efficiently."
    },
    {
      "type": "text",
      "text": "Reflection: You learned how iterators and generators work under the hood, how Python’s for loop uses the iterator protocol, and how yield allows memory-efficient sequences. Understanding this helps you write efficient, flexible loops."
    }
  ]
}
